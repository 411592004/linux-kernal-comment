	Linux 1.2版本内核，虽然和现在的3.x版本相差二十多年，但它并没有过时，特别是对于我们学习操作系统的理论与实现。
	笔者在研究1.2内核之前看过1.0版本的内核，也曾有过以1.0内核为蓝本进行操作系统内核的学习，但是，我很庆幸最终选
择了1.2版本。我感觉1.0内核虽然是Linux的第一个可用的发行版本，但是内核代码中好多东西都没有实现，感觉比较杂乱，好多想
追踪的内核机制都找不到相应的代码模块。
	笔者曾经也研究过Linux0.11内核，读的是赵炯博士的《Linux内核完全注释》，研究了一个学期，感觉这个版本最小，但真的很精悍。
1.0和0.11相比，1.0大约16万行代码，有点庞大，而0.11内核只有一万多行，可以让人在很短的时间里对内核机制从整体有一个认识和把握，
而且这个认识和把握可以通过这一万多行代码理解的很深入，之后再研究庞大的新版本内核，遇到问题起码知道从哪里想问题，从哪里寻找解决
方案，从哪里追踪内核代码。
	笔者认为，1.2版本内核代码最然有30多万行代码，但已经是一个真正意义上的操作系统了，内部机制也比较完善。和现代内核版本相比，
他更为简练，也更为接近问题的本质。一个操作系统，无论变得多么庞大，总会有她最核心的核心代码和机制，但是，内核越大，这个核心就隐蔽
的越深，就越不容易把握。所以，我觉得1.2版本很适合让人去掌握这个核心中的核心。
	笔者在研究1.2内核的过程中，也深刻的体会到了这个道理。最然针对这个版本的原始资料很少，但是现在存在的大量讲解现在版本内核的资料和
经典名著，也同样适用于Linux1.2。1.2和现代内核相比，少了多处理机机制SMP，没有多线程等等，所以他很精简。现代内核其实可以看做是对这个版本
内核的扩充和封装。扩充就是增加了新的机制，比如SMP等，封装就是定义了许多方便内核操作的宏，将原内核的一个函数分解成几个函数，或者将一个源文件
分为几个源文件，并置于一个独立的文件夹下，也即模块化。还有就是对旧的机制起了新的名字，所谓的换汤不换药。
	在现代内核中的代码，甚至保留了1.2版本中相应代码的注释---连注释都一样。
	linux2.0版本内核代码量比1.2翻了一倍，但增加的基本全是驱动程序，核心没有变动。
	《2014.11.10》
	最近就要编译原理课考试了，今晚去自习，研究编译原理的考试题，深有体会。一方面，感觉隐藏在具体的规则和方法之后的哲学才是所有学科的基础，
	因为对于许多解题方法，都是直接教给你怎么解题，用什么样的具体方法和规则，但并没有给出这样做的原因，这样的学习甚至都是不知其然也不知其
所以然的。这样的学习也最多不过是应付一下考试而已，考试过后，什么都忘了。但是用哲学方法去思考问题的话，许多问题背后隐含的博大精深的思想都理解了，
这样的收获是一辈子都不会忘记的。另一方面的收获就是，研究现象背后的本质，最好从最简单的现象开始，就像做题一样，如果选择比较简单、简练的题型开始研究，
那么过程和方法是简单明了的，可以在短时间内理解隐藏在其背后的思想和哲学，但如果是从复杂的题型开始研究的话，那就太复杂了，眼花缭乱，大多还是将注意力集中在解题的过程中了，还如何容易透过现象看本质呢？所以，对于同一个学习研究对象，既然其背后的至简原理是相同的，那么就不如选择一个简单明了的模型来研究学习，模型越简单越接近核心，模型越复杂与核心相关的东西就越多，当我们经过艰辛的努力层层剖析开来，最终还是发现，最内层的问题还是这个简单的模型。学习内核也是一样的道理。
	《2014.11.16》
	形式可能也必然会改变，但原理是不会改变的，特别是原理背后的原理。一种新的设计思路或许会被提出和实现，但是新的设计所依据的原理还是那个原理。
